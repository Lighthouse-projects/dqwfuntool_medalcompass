# データベース設計書

## 概要

MedalCompass（dqwfunメダルコンパス）で使用するSupabase PostgreSQLデータベースのスキーマ設計。

**基本思想:**
- クライアントから直接PostgreSQLにアクセス（Edge Functions不使用でコスト$0/月）
- Row Level Security (RLS)でセキュリティを確保
- 読み取りは全員公開、書き込みは認証済みユーザーが自分のデータのみ操作可能

---

## テーブル一覧

| テーブル名 | 用途 |
|-----------|------|
| auth.users | ユーザー認証情報（Supabase Auth標準） |
| medal_mst_seasons | シーズンマスタ（年×四季で管理） |
| medal_medals | メダル位置情報（緯度・経度・シーズン） |
| medal_reports | 誤メダル通報履歴（運営が手動対応） |
| medal_collections | メダル獲得履歴（探検モード用） |
| medal_requests | ユーザー要望（不具合・機能要望・質問等） |
| medal_announcements | 運営からのお知らせ（メンテナンス・障害・新機能等） |

---

## 1. auth.users

**目的:**
- Supabase Auth標準のユーザー認証テーブル
- JWT認証とRLSの`auth.uid()`で自動認証制御

**DDL:**
```sql
-- Supabase Authにより自動作成・管理
-- 手動作成不要
```

---

## 2. medal_mst_seasons

**目的:**
- メダルをシーズン（年×四季）で管理
- 過去シーズンは読み取り専用、現在シーズンは書き込み可能
- 一般ユーザーは参照のみ、管理者が手動でシーズンを追加

**設計思想:**
- 年と四季の組み合わせで一意性を保証（UNIQUE制約）
- ENUM型で四季の値を厳密に管理（'春','夏','秋','冬'のみ許可）
- display_nameで画面表示用の文字列を保持（YYYY/春形式）
- is_currentフラグで現在シーズンを明示的に管理（1レコードのみtrue）

**DDL:**
```sql
-- ENUM型作成
CREATE TYPE season_enum AS ENUM ('春', '夏', '秋', '冬');

-- テーブル作成
CREATE TABLE medal_mst_seasons (
  season_no integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,  -- シーズン番号（連番、データ移行時は値指定可能）
  year integer NOT NULL CHECK (year >= 2025),                  -- 年（2025年以降のみ）
  season season_enum NOT NULL,                                 -- 四季（春/夏/秋/冬）
  display_name varchar(20) NOT NULL,                           -- 表示名（YYYY/春形式）
  is_current boolean NOT NULL DEFAULT false,                   -- 現在シーズンフラグ（1レコードのみtrue）
  created_at timestamptz NOT NULL DEFAULT now(),               -- 作成日時
  CONSTRAINT unique_year_season UNIQUE (year, season)          -- 年と四季の組み合わせで一意
);

-- インデックス作成
CREATE UNIQUE INDEX idx_medal_mst_seasons_unique ON medal_mst_seasons (year, season);          -- 重複シーズン防止
CREATE INDEX idx_medal_mst_seasons_display_name ON medal_mst_seasons (display_name);           -- 表示名検索用
CREATE INDEX idx_medal_mst_seasons_is_current ON medal_mst_seasons (is_current);               -- 現在シーズン検索用

-- 初期データ挿入
INSERT INTO medal_mst_seasons (year, season, display_name, is_current)
VALUES (2025, '秋', '2025/秋', true);

-- RLSポリシー設定
ALTER TABLE medal_mst_seasons ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Seasons are viewable by everyone" ON medal_mst_seasons FOR SELECT USING (true);  -- 全員閲覧可能
CREATE POLICY "Seasons cannot be modified by users" ON medal_mst_seasons FOR ALL USING (false); -- ユーザーは変更不可
```

---

## 3. medal_medals

**目的:**
- ドラクエウォークの小さなメダルの湧き位置を保存
- ユーザーが登録したメダルの緯度・経度をシーズンごとに管理

**設計思想:**
- メダル番号（medal_no）は連番で自動採番、何個登録されたかが一目でわかる
- シーズンごとにメダルを管理（season_no外部キー）
- 物理削除方式（ユーザーまたは運営が削除時にDELETE実行）
- 位置情報は小数点以下8桁で約1.1mmの精度
- ON DELETE CASCADEでユーザー削除時にメダルも自動削除
- ON DELETE RESTRICTでメダルが存在するシーズンは削除不可

**DDL:**
```sql
-- テーブル作成
CREATE TABLE medal_medals (
  medal_no bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,                              -- メダル番号（連番、データ移行時は値指定可能）
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,                         -- 登録ユーザーID
  season_no integer NOT NULL REFERENCES medal_mst_seasons(season_no) ON DELETE RESTRICT,     -- シーズン番号
  latitude decimal(10, 8) NOT NULL CHECK (latitude >= -90 AND latitude <= 90),               -- 緯度
  longitude decimal(11, 8) NOT NULL CHECK (longitude >= -180 AND longitude <= 180),          -- 経度
  created_at timestamptz NOT NULL DEFAULT now(),                                             -- 登録日時
  updated_at timestamptz NOT NULL DEFAULT now()                                              -- 最終更新日時
);

-- インデックス作成
CREATE INDEX idx_medal_medals_season_no ON medal_medals (season_no);          -- シーズン絞り込み用
CREATE INDEX idx_medal_medals_location ON medal_medals (latitude, longitude); -- 地理座標検索用
CREATE INDEX idx_medal_medals_user_id ON medal_medals (user_id);              -- ユーザー別メダル検索用

-- RLSポリシー設定
ALTER TABLE medal_medals ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Medals are viewable by everyone" ON medal_medals FOR SELECT USING (true);                        -- 全員閲覧可能
CREATE POLICY "Users can insert their own medals" ON medal_medals FOR INSERT WITH CHECK (auth.uid() = user_id); -- 自分のIDでのみ登録可能
CREATE POLICY "Users can delete their own medals" ON medal_medals FOR DELETE USING (auth.uid() = user_id);      -- 自分のメダルのみ削除可能
```

---

## 4. medal_reports

**目的:**
- 誤メダル通報の履歴を保存
- 運営が通報データを確認し、手動でメダル削除・ユーザーBAN判断を実施

**設計思想:**
- 1ユーザーが1メダルに対して1回のみ通報可能（UNIQUE制約で重複防止）
- 通報は取り消し不可（DELETE/UPDATEポリシーでfalse）
- 通報履歴は永続的に保持（監査証跡として運営が参照）
- ON DELETE CASCADEでメダル・ユーザー削除時に通報履歴も自動削除

**DDL:**
```sql
-- テーブル作成
CREATE TABLE medal_reports (
  report_id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,                          -- 通報ID（連番、データ移行時は値指定可能）
  medal_no bigint NOT NULL REFERENCES medal_medals(medal_no) ON DELETE CASCADE,           -- 通報対象のメダル番号
  reporter_user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,             -- 通報したユーザーID
  created_at timestamptz NOT NULL DEFAULT now(),                                          -- 通報日時
  CONSTRAINT unique_medal_reporter UNIQUE (medal_no, reporter_user_id)                    -- 重複通報防止
);

-- インデックス作成
CREATE UNIQUE INDEX idx_medal_reports_unique ON medal_reports (medal_no, reporter_user_id); -- 重複通報防止（UNIQUE）
CREATE INDEX idx_medal_reports_medal_no ON medal_reports (medal_no);                        -- 通報数カウント用
CREATE INDEX idx_medal_reports_reporter ON medal_reports (reporter_user_id);                -- ユーザーの通報履歴用

-- RLSポリシー設定
ALTER TABLE medal_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Reports are viewable by everyone" ON medal_reports FOR SELECT USING (true);                             -- 全員閲覧可能
CREATE POLICY "Users can insert their own reports" ON medal_reports FOR INSERT WITH CHECK (auth.uid() = reporter_user_id); -- 自分のIDでのみ通報可能
CREATE POLICY "Reports cannot be deleted" ON medal_reports FOR DELETE USING (false);                                   -- 削除不可（取り消し不可）
CREATE POLICY "Reports cannot be updated" ON medal_reports FOR UPDATE USING (false);                                   -- 更新不可（改ざん防止）
```

---

## 5. medal_collections

**目的:**
- メダル獲得履歴を保存
- 探検モードで獲得済みメダルをグレー表示するために使用
- メダルの思い出（獲得履歴）画面で日付フィルタリング

**設計思想:**
- 1ユーザーが1メダルに対して1回のみ獲得記録可能（UNIQUE制約で重複防止）
- 誤獲得の取り消しは可能（DELETEポリシーで自分の履歴のみ削除可能）
- 獲得日時の改ざん防止（UPDATEポリシーでfalse）
- ON DELETE CASCADEでメダル・ユーザー削除時に獲得履歴も自動削除

**DDL:**
```sql
-- テーブル作成
CREATE TABLE medal_collections (
  collection_id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,              -- 獲得ID（連番、データ移行時は値指定可能）
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,              -- 獲得したユーザーID
  medal_no bigint NOT NULL REFERENCES medal_medals(medal_no) ON DELETE CASCADE,   -- 獲得したメダル番号
  collected_at timestamptz NOT NULL DEFAULT now(),                                -- 獲得日時
  CONSTRAINT unique_user_medal UNIQUE (user_id, medal_no)                         -- 重複獲得防止
);

-- インデックス作成
CREATE UNIQUE INDEX idx_medal_collections_unique ON medal_collections (user_id, medal_no); -- 重複獲得防止（UNIQUE）
CREATE INDEX idx_medal_collections_user_id ON medal_collections (user_id);                 -- ユーザーの獲得履歴用
CREATE INDEX idx_medal_collections_medal_no ON medal_collections (medal_no);               -- メダルの獲得者一覧用

-- RLSポリシー設定
ALTER TABLE medal_collections ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Collections are viewable by everyone" ON medal_collections FOR SELECT USING (true);                      -- 全員閲覧可能
CREATE POLICY "Users can insert their own collections" ON medal_collections FOR INSERT WITH CHECK (auth.uid() = user_id); -- 自分のIDでのみ獲得記録可能
CREATE POLICY "Users can delete their own collections" ON medal_collections FOR DELETE USING (auth.uid() = user_id);     -- 自分の獲得履歴のみ削除可能
CREATE POLICY "Collections cannot be updated" ON medal_collections FOR UPDATE USING (false);                            -- 更新不可（改ざん防止）
```

---

## 6. medal_requests

**目的:**
- ユーザーから運営への要望を保存
- 不具合報告・機能要望・質問などをカテゴリー別に管理
- 対応状況と運営からの回答コメントを表示

**設計思想:**
- カテゴリーと対応状況をENUM型で厳密に管理
- 要望内容は最大500文字で制限（長文防止）
- 運営からの回答コメントは任意（未回答の場合はNULL）
- 対応状況のデフォルトは'pending'（未対応）
- ON DELETE CASCADEでユーザー削除時に要望も自動削除

**DDL:**
```sql
-- ENUM型作成
CREATE TYPE request_category_enum AS ENUM ('bug', 'feature', 'question', 'other');
CREATE TYPE request_status_enum AS ENUM ('pending', 'in_progress', 'completed', 'rejected');

-- テーブル作成
CREATE TABLE medal_requests (
  request_no bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,           -- 要望番号（連番、データ移行時は値指定可能）
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,        -- 送信者ユーザーID
  category request_category_enum NOT NULL,                                  -- 要望カテゴリー
  content text NOT NULL CHECK (char_length(content) <= 500),                -- 要望内容（最大500文字）
  status request_status_enum NOT NULL DEFAULT 'pending',                    -- 対応状況（デフォルト: 未対応）
  admin_comment text,                                                       -- 運営者からの回答コメント（任意）
  created_at timestamptz NOT NULL DEFAULT now(),                            -- 送信日時
  updated_at timestamptz NOT NULL DEFAULT now()                             -- 更新日時
);

-- インデックス作成
CREATE INDEX idx_medal_requests_user_id ON medal_requests (user_id);       -- ユーザー別要望検索用
CREATE INDEX idx_medal_requests_status ON medal_requests (status);         -- 対応状況検索用
CREATE INDEX idx_medal_requests_category ON medal_requests (category);     -- カテゴリー検索用

-- RLSポリシー設定
ALTER TABLE medal_requests ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own requests" ON medal_requests FOR SELECT USING (auth.uid() = user_id);          -- 自分の要望のみ閲覧可能
CREATE POLICY "Users can insert their own requests" ON medal_requests FOR INSERT WITH CHECK (auth.uid() = user_id);   -- 自分のIDでのみ要望送信可能
CREATE POLICY "Users cannot update requests" ON medal_requests FOR UPDATE USING (false);                              -- ユーザーは更新不可（運営のみ）
CREATE POLICY "Users cannot delete requests" ON medal_requests FOR DELETE USING (false);                              -- ユーザーは削除不可（運営のみ）
```

**カテゴリー説明:**
- `bug`: 不具合報告（アプリの不具合報告）
- `feature`: 機能要望（新機能や改善の要望）
- `question`: 質問（使い方などの質問）
- `other`: その他（上記に該当しない要望）

**対応状況説明:**
- `pending`: 未対応（まだ運営が確認していない）
- `in_progress`: 対応中（運営が対応を進めている）
- `completed`: 対応完了（対応が完了した）
- `rejected`: 対応不可（対応できないと判断された）

---

## 7. medal_announcements

**目的:**
- 運営からユーザーへのお知らせを管理
- メンテナンス予告、障害情報、新機能リリース等を配信

**設計思想:**
- お知らせの種類をENUM型で厳密に管理（info/warning/emergency）
- 表示期間で自動的に表示/非表示を制御
- 優先度順、作成日時順で表示順を制御
- 既読管理はサービス開始時は実装しない（将来対応予定）

**DDL:**
```sql
-- ENUM型作成
CREATE TYPE announcement_type_enum AS ENUM ('info', 'warning', 'emergency');

-- テーブル作成
CREATE TABLE medal_announcements (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,           -- お知らせID（連番）
  announcement_type announcement_type_enum NOT NULL,            -- お知らせの種類（info/warning/emergency）
  title varchar(100) NOT NULL,                                  -- タイトル（最大100文字）
  content text NOT NULL,                                        -- 内容（マークダウン対応）
  display_start_at timestamptz NOT NULL DEFAULT now(),          -- 表示開始日時
  display_end_at timestamptz NOT NULL,                          -- 表示終了日時
  created_at timestamptz NOT NULL DEFAULT now(),                -- 作成日時
  updated_at timestamptz NOT NULL DEFAULT now()                 -- 更新日時
);

-- インデックス作成
CREATE INDEX idx_medal_announcements_type ON medal_announcements (announcement_type);              -- 種類検索用
CREATE INDEX idx_medal_announcements_display_period ON medal_announcements (display_start_at, display_end_at); -- 表示期間検索用
CREATE INDEX idx_medal_announcements_created_at ON medal_announcements (created_at DESC);          -- 作成日時降順

-- RLSポリシー設定
ALTER TABLE medal_announcements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Announcements are viewable by everyone" ON medal_announcements FOR SELECT USING (true);  -- 全員閲覧可能
CREATE POLICY "Announcements cannot be modified by users" ON medal_announcements FOR ALL USING (false); -- ユーザーは変更不可（運営のみ管理）
```

**データ取得例:**
```sql
-- 有効なお知らせを優先度順・作成日時降順で取得
SELECT * FROM medal_announcements
WHERE display_start_at <= now()
  AND display_end_at >= now()
ORDER BY
  CASE announcement_type
    WHEN 'emergency' THEN 1
    WHEN 'warning' THEN 2
    WHEN 'info' THEN 3
  END,
  created_at DESC;
```

**お知らせの種類:**
- `info`: 情報（新機能リリース、お知らせ等）
- `warning`: 警告（定期メンテナンス予告等）
- `emergency`: 緊急（緊急メンテナンス、障害情報等）

**フォールバック機能:**
- Supabase障害時は、GitHub Gistから障害情報を取得
- URL: `https://gist.githubusercontent.com/kikutake/125d6f997d2217d2ee0fd74ccc5a146d/raw/`
- JSONフォーマット: `{ "isDown": boolean, "message": string, "updatedAt": string }`

---

## アカウント削除時のデータ削除

**概要:**
- ユーザーがアカウントを削除すると、関連する全データが自動的に削除される
- `ON DELETE CASCADE`により、auth.usersの削除をトリガーに連鎖削除が実行される

**削除される順序:**
1. **auth.users（ユーザーアカウント）を削除**
2. 以下のテーブルが自動的に連鎖削除（CASCADE）:
   - medal_medals（登録したメダル）
   - medal_collections（メダル獲得履歴）
   - medal_reports（通報履歴 - 通報者として）
   - medal_requests（送信した要望）
3. medal_medalsの削除により、さらに以下が連鎖削除:
   - medal_reports（該当メダルへの通報）

**実装方法:**
```typescript
// クライアント側からEdge Functionを呼び出し
const { data, error } = await supabase.functions.invoke('delete-account', {
  body: { password: userPassword } // パスワード再確認
})

// Edge Function内部でユーザー削除を実行
// supabase.auth.admin.deleteUser(userId)
// → ON DELETE CASCADEで関連データが自動削除される
```

**セキュリティ:**
- Edge Functionを使用してサーバーサイドで削除実行
- クライアントに管理者権限キーを公開しない
- パスワード再確認による本人認証

**データ復元:**
- アカウント削除後のデータ復元は不可
- 削除前に必ず確認ダイアログで警告を表示

---

## 実行順序

Supabaseダッシュボードで以下の順番にSQLを実行してください:

1. ENUM型の作成（`CREATE TYPE season_enum`, `request_category_enum`, `request_status_enum`, `announcement_type_enum`）
2. medal_mst_seasonsテーブル（テーブル作成 → インデックス → 初期データ → RLS）
3. medal_medalsテーブル（テーブル作成 → インデックス → RLS）
4. medal_reportsテーブル（テーブル作成 → インデックス → RLS）
5. medal_collectionsテーブル（テーブル作成 → インデックス → RLS）
6. medal_requestsテーブル（テーブル作成 → インデックス → RLS）
7. medal_announcementsテーブル（テーブル作成 → インデックス → RLS）
